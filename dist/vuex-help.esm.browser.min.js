/**
 * vuex v0.1.1
 * (c) 2020 Steven Lin
 * @license MIT
 */
function t(t,e){return function t(n,e,o=[]){const r=Object.keys(n).reduce((r,u)=>{const c=n[u];if(o.push(u),function(t){return null!==t&&"object"==typeof t}(c))return{...r,[u]:t(c,e,o)};const i=e.create(o,c);return o.pop(),{...r,[u]:i}},{});const u=e.create(o,r);o.pop();return u}(t,new n(e))}class n{constructor(t){this.context=t}create(t,n){const[o,r,u]=t;if("state"===r)return e(n)?n():n;const c=`${o}/${u}`;if(o&&u)switch(function(t,n){if(!t)throw new Error(`[vuex-help] ${n}`)}(e(n),"value must be an function"),r){case"mutations":return this.applyFun(function(...t){this.commit(c,...t)});case"actions":return this.applyFun(function(...t){this.dispatch(c,...t)});case"getters":return this.applyFun(function(...t){this.getters[c](...t)})}return n}applyFun(t){return(...n)=>t.apply(this.context,n)}}function e(t){return t&&"[object Function]"==={}.toString.call(t)}const o=function({modules:n}){return{beforeCreate(){const e=this.$options;e.computed||(e.computed={}),e.computed.$h||(e.computed.$h=function(){return t(n,this.$store)})}}};let r;function u(t,n){r&&t===r||function(t,n){if(Number(t.version.split(".")[0])>2)throw Error("version not supported");t.mixin(o(n))}(r=t,n)}export default{install:u,version:"0.1.1"};export{u as install};